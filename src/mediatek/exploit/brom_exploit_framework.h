#pragma once

#include <QByteArray>
#include <QList>
#include <QObject>
#include <QString>
#include <cstdint>
#include <functional>
#include <memory>
#include <vector>

namespace sakura {

class ITransport;
class BromClient;

// ── BROM exploit target definitions ─────────────────────────────────────────

struct BromExploitTarget {
    uint16_t hwCode = 0;
    QString  chipName;

    // Memory layout (chip-specific)
    uint32_t bromBase = 0;
    uint32_t bromSize = 0;
    uint32_t sramBase = 0;
    uint32_t sramSize = 0;
    uint32_t dramBase = 0;

    // Exploit-specific addresses
    uint32_t payloadAddr = 0;      // Where to place shellcode
    uint32_t usbDmaAddr  = 0;      // USB DMA buffer address
    uint32_t cacheCtrlAddr = 0;    // Cache control register

    // Security bypass addresses
    uint32_t securityPtr = 0;      // Pointer to security flag
    uint32_t slaCheckAddr = 0;     // SLA check function address
    uint32_t daaCheckAddr = 0;     // DAA check function address
};

// ── Payload generation helpers ──────────────────────────────────────────────

struct BromPayload {
    QByteArray shellcode;          // ARM Thumb-2 shellcode
    uint32_t   entryPoint = 0;
    QString    description;
};

enum class ExploitType {
    None = 0,
    Carbonara,                     // write32 primitive via BROM protocol
    Kamakiri2                      // USB control transfer primitive
};

// ── Result of an exploit attempt ────────────────────────────────────────────

struct ExploitResult {
    bool success = false;
    ExploitType type = ExploitType::None;
    QString message;
    QByteArray bromDump;           // Optional: dumped BROM image
};

// ── Abstract base for BROM exploits ─────────────────────────────────────────

class IBromExploit : public QObject {
    Q_OBJECT

public:
    using QObject::QObject;
    virtual ~IBromExploit() = default;

    virtual ExploitType exploitType() const = 0;
    virtual QString name() const = 0;
    virtual bool isSupported(uint16_t hwCode) const = 0;

    virtual ExploitResult execute(BromClient* brom,
                                  ITransport* transport,
                                  const BromExploitTarget& target) = 0;

signals:
    void progressMessage(const QString& message);
};

// ── BROM exploit framework — selects and runs the right exploit ─────────────

class BromExploitFramework : public QObject {
    Q_OBJECT

public:
    explicit BromExploitFramework(QObject* parent = nullptr);
    ~BromExploitFramework() override;

    // Register exploit implementations
    void registerExploit(std::unique_ptr<IBromExploit> exploit);

    // Execute the best available exploit for this device
    ExploitResult exploit(BromClient* brom, ITransport* transport, uint16_t hwCode);

    // Query
    bool hasExploit(uint16_t hwCode) const;
    QList<ExploitType> availableExploits(uint16_t hwCode) const;

    // Target database
    static BromExploitTarget targetForHwCode(uint16_t hwCode);

signals:
    void progressMessage(const QString& message);

private:
    std::vector<std::unique_ptr<IBromExploit>> m_exploits;

    // Built-in target definitions
    static void initTargetDatabase();
    static QMap<uint16_t, BromExploitTarget> s_targets;
    static bool s_targetsInitialized;
};

} // namespace sakura
