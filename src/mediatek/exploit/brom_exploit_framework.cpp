#include "brom_exploit_framework.h"
#include "mediatek/protocol/brom_client.h"
#include "core/logger.h"

#include <QMap>

namespace sakura {

static constexpr char LOG_TAG[] = "MTK-EXPLOIT";

QMap<uint16_t, BromExploitTarget> BromExploitFramework::s_targets;
bool BromExploitFramework::s_targetsInitialized = false;

BromExploitFramework::BromExploitFramework(QObject* parent)
    : QObject(parent)
{
    if (!s_targetsInitialized)
        initTargetDatabase();
}

BromExploitFramework::~BromExploitFramework() = default;

// ── Registration ────────────────────────────────────────────────────────────

void BromExploitFramework::registerExploit(std::unique_ptr<IBromExploit> exploit)
{
    connect(exploit.get(), &IBromExploit::progressMessage,
            this, &BromExploitFramework::progressMessage);
    m_exploits.push_back(std::move(exploit));
}

// ── Execution ───────────────────────────────────────────────────────────────

ExploitResult BromExploitFramework::exploit(BromClient* brom, ITransport* transport,
                                             uint16_t hwCode)
{
    BromExploitTarget target = targetForHwCode(hwCode);
    if (target.hwCode == 0) {
        return { false, ExploitType::None,
                 QString("No target definition for HW code 0x%1")
                     .arg(hwCode, 4, 16, QChar('0')),
                 {} };
    }

    LOG_INFO_CAT(LOG_TAG, QString("Attempting exploit on %1 (0x%2)")
                              .arg(target.chipName)
                              .arg(hwCode, 4, 16, QChar('0')));

    // Try each registered exploit in order
    for (auto& exp : m_exploits) {
        if (!exp->isSupported(hwCode))
            continue;

        LOG_INFO_CAT(LOG_TAG, QString("Trying exploit: %1").arg(exp->name()));
        emit progressMessage(QString("Running %1...").arg(exp->name()));

        ExploitResult result = exp->execute(brom, transport, target);
        if (result.success) {
            LOG_INFO_CAT(LOG_TAG, QString("Exploit succeeded: %1").arg(exp->name()));
            return result;
        }

        LOG_WARNING_CAT(LOG_TAG, QString("Exploit %1 failed: %2")
                                     .arg(exp->name(), result.message));
    }

    return { false, ExploitType::None, "All exploits failed", {} };
}

// ── Query ───────────────────────────────────────────────────────────────────

bool BromExploitFramework::hasExploit(uint16_t hwCode) const
{
    for (const auto& exp : m_exploits) {
        if (exp->isSupported(hwCode))
            return true;
    }
    return false;
}

QList<ExploitType> BromExploitFramework::availableExploits(uint16_t hwCode) const
{
    QList<ExploitType> types;
    for (const auto& exp : m_exploits) {
        if (exp->isSupported(hwCode))
            types.append(exp->exploitType());
    }
    return types;
}

BromExploitTarget BromExploitFramework::targetForHwCode(uint16_t hwCode)
{
    if (!s_targetsInitialized)
        initTargetDatabase();

    return s_targets.value(hwCode, {});
}

// ── Target database ─────────────────────────────────────────────────────────

void BromExploitFramework::initTargetDatabase()
{
    s_targetsInitialized = true;

    // MT6761 / Helio A20
    s_targets[0x0717] = {
        0x0717, "MT6761",
        0x00000000, 0x00010000,    // bromBase, bromSize
        0x00100000, 0x00020000,    // sramBase, sramSize
        0x40000000,                // dramBase
        0x00105000,                // payloadAddr
        0x00110000,                // usbDmaAddr
        0x00000000,                // cacheCtrlAddr
        0x001024B4,                // securityPtr
        0x00000000,                // slaCheckAddr
        0x00000000                 // daaCheckAddr
    };

    // MT6765 / Helio P35
    s_targets[0x0766] = {
        0x0766, "MT6765",
        0x00000000, 0x00010000,
        0x00100000, 0x00020000,
        0x40000000,
        0x00105000,
        0x00110000,
        0x00000000,
        0x001024B4,
        0x00000000,
        0x00000000
    };

    // MT6771 / Helio P60
    s_targets[0x0788] = {
        0x0788, "MT6771",
        0x00000000, 0x00010000,
        0x00100000, 0x00030000,
        0x40000000,
        0x00105000,
        0x00110000,
        0x00000000,
        0x00102760,
        0x00000000,
        0x00000000
    };

    // MT6785 / Helio G90
    s_targets[0x0813] = {
        0x0813, "MT6785",
        0x00000000, 0x00010000,
        0x00100000, 0x00030000,
        0x40000000,
        0x00105000,
        0x00110000,
        0x00000000,
        0x001024B4,
        0x00000000,
        0x00000000
    };

    // MT6833 / Dimensity 700
    s_targets[0x0886] = {
        0x0886, "MT6833",
        0x00000000, 0x00010000,
        0x00100000, 0x00030000,
        0x40000000,
        0x00105000,
        0x00110000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000
    };

    // MT6853 / Dimensity 720
    s_targets[0x0950] = {
        0x0950, "MT6853",
        0x00000000, 0x00010000,
        0x00100000, 0x00030000,
        0x40000000,
        0x00105000,
        0x00110000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000
    };

    // MT6873 / Dimensity 800
    s_targets[0x0959] = {
        0x0959, "MT6873",
        0x00000000, 0x00010000,
        0x00100000, 0x00030000,
        0x40000000,
        0x00105000,
        0x00110000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000
    };

    // MT6893 / Dimensity 1200
    s_targets[0x0996] = {
        0x0996, "MT6893",
        0x00000000, 0x00010000,
        0x00100000, 0x00030000,
        0x40000000,
        0x00105000,
        0x00110000,
        0x00000000,
        0x00000000,
        0x00000000,
        0x00000000
    };

    // TODO: Add more SoC targets as needed
}

} // namespace sakura
