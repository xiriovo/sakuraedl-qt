#pragma once

#include "mediatek/exploit/brom_exploit_framework.h"

namespace sakura {

// ── Kamakiri2 exploit ───────────────────────────────────────────────────────
//
// USB-based exploit that uses control transfers to trigger a heap/stack
// corruption in the BROM's USB handler, achieving arbitrary code execution.
//
// This is a more powerful exploit than Carbonara as it works even when
// CMD_READ32/CMD_WRITE32 are disabled on newer BROM versions.
//
// Flow:
//   1. Send crafted USB control transfer to trigger buffer overflow
//   2. Overwrite return address on stack with payload address
//   3. Payload disables security checks and returns to normal BROM flow
//   4. Device now accepts unsigned DAs
//
// Requires USB transport (will not work over UART/serial).
//

class Kamakiri2Exploit : public IBromExploit {
    Q_OBJECT

public:
    explicit Kamakiri2Exploit(QObject* parent = nullptr);
    ~Kamakiri2Exploit() override;

    ExploitType exploitType() const override { return ExploitType::Kamakiri2; }
    QString name() const override { return QStringLiteral("Kamakiri2"); }
    bool isSupported(uint16_t hwCode) const override;

    ExploitResult execute(BromClient* brom, ITransport* transport,
                          const BromExploitTarget& target) override;

private:
    // USB control transfer primitive
    bool sendUsbControlTransfer(ITransport* transport, uint8_t bRequest,
                                 uint16_t wValue, uint16_t wIndex,
                                 const QByteArray& data);

    // Build the payload that will be executed in BROM context
    QByteArray buildPayload(const BromExploitTarget& target);

    // Place payload in SRAM via USB DMA
    bool placePayload(ITransport* transport, const BromExploitTarget& target,
                      const QByteArray& payload);

    // Trigger the overflow
    bool triggerOverflow(ITransport* transport, const BromExploitTarget& target);

    static const QList<uint16_t> s_supportedHwCodes;
};

} // namespace sakura
